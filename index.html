<!DOCTYPE html>
<html lang="en">
<head>
    <style type="text/css">
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        margin: 0;
        padding: 0;
		background: #000000;
    }
    </style>
    <title>vecvid</title>
</head>
<body>
    <script src="primitives/Primitive.js"></script>
	<script src="primitives/Lineto.js"></script>
	<script src="primitives/Moveto.js"></script>
	<script src="primitives/BezierCurve.js"></script>
    <script src="jSignature.js"></script>
    <script src="simplify.js"></script>
    <script>
		const FRAME_WIDTH = 1920
		const FRAME_HEIGHT = 800
	
        let canvasEl = document.createElement('canvas')
        canvasEl.width = FRAME_WIDTH
        canvasEl.height = FRAME_HEIGHT
		let canvasWidth = FRAME_WIDTH / 3
		let canvasHeight = FRAME_HEIGHT / 3
		canvasEl.style.width = canvasWidth + 'px'
		canvasEl.style.height = canvasHeight + 'px'
		canvasEl.style.margin = ((innerHeight - canvasHeight) / 2) + 'px ' + ((innerWidth - canvasWidth) / 2) + 'px'
        document.body.appendChild(canvasEl)

        let ctx = canvasEl.getContext('2d')

        let xhrData = new XMLHttpRequest
        xhrData.responseType = 'blob'
        xhrData.onload = function () {
            let reader = new FileReader
            let bitstream = this.response
            reader.onload = function () {
                let bytes = new Uint8ClampedArray(this.result)
                let byteLen = bytes.length
                let bitIndex = 0
                let byteIndex = 0
				let state = {ready: false}
				
				let pos = 0
				let frameSizes = []
				let frameCount = bytes[pos] << 8 | bytes[pos + 1] & 0xFF
				pos = 2
				//frameCount--
				function getBit() {
					if (bitIndex == 8) {
						bitIndex = 0
						byteIndex++
					}
					if (byteIndex >= byteLen) {
						return false
					}
					let bit = (bytes[byteIndex] & (1 << (7 - bitIndex))) != 0 ? '1' : '0'
					bitIndex++
					return bit
				}
				
				function getByte() {
					return getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit()
				}

				let mSmallDeltas = {
					/*0b00: -1,
 					0b01: 0,
					0b10: 1*/
					0b000: {x: -1, y: -1},
					0b001: {x: -1, y: 0},
					0b010: {x: -1, y: 1},
					0b011: {x: 0, y: -1},
					0b100: {x: 0, y: 1},
					0b101: {x: 1, y: -1},
					0b110: {x: 1, y: 0},
					0b111: {x: 1, y: 1}
				}

				let byteIdx = 2
				for (let i = 0; i < frameCount; i++) {
					let frameBytes = bytes[pos] << 16 | bytes[pos+1] << 8 | bytes[pos+2] & 0xFF
					let frameBits = bytes[pos+3] & 0xFF
					byteIdx += frameBytes
					frameSizes.push({bytes: byteIdx, bits: frameBits})
					pos += 4
				}
				state.fIndex = 0
				
				let preBytes = pos
				window.compSize = 0
				function playFrame() {
				    let sTime = Number(new Date)
					if (state.fIndex>0) {
						byteIndex = preBytes - 2 + frameSizes[state.fIndex].bytes
						bitIndex = frameSizes[state.fIndex].bits
					}
					else {
						byteIndex = pos
						bitIndex = 0
					}

					let colorCount = getByte() << 8
					colorCount |= getByte()

					let shapes = []
					let colors = []

					ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)

					let imdata = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)

					for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
						let bit = getBit()
						if (bit == '0') {
							state.fIndex++
							playFrame()
							return
						} else {
							let red = getByte()
							let green = getByte()
							let blue = getByte()

							let contourCount = (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())						
							
							compSize += 6

							let knots = []
							for (let contourIndex = 0; contourIndex < contourCount; contourIndex++) {
								let firstPointX = (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
								let firstPointY = (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
								let innerContourCount
								
								compSize += 2
								
								if (getBit() == '1') {
									if (getBit() == '1') {
										innerContourCount = (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
									}
									else {
										innerContourCount = getByte()
									}
								} else {
									innerContourCount = 1;
								}

								let curPoint = {x: firstPointX, y: firstPointY}
								let curDelta = {x: 0, y: 0}

								let idx = FRAME_WIDTH * curPoint.y * 4 + curPoint.x * 4
								imdata.data[idx] = red
								imdata.data[idx + 1] = green
								imdata.data[idx + 2] = blue
								imdata.data[idx + 3] = 255

								knots.push(curPoint)

								for (let innerContourIndex = 1; innerContourIndex < innerContourCount; innerContourIndex++) {
									let bitIsDifferent = getBit() == '1'

									if (bitIsDifferent) {
										let x;
										let y;
										if (getBit() == '1') {
											x = (getBit() == '1' ? -1 : 1) * (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
											y = (getBit() == '1' ? -1 : 1) * (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
										} else {
											let delta = mSmallDeltas[getBit() << 2 | getBit() << 1 | getBit()]
											x = delta.x
											y = delta.y
										}
										curDelta = {x: x, y: y}
									} else {
									}
									
									curPoint.x += curDelta.x
									curPoint.y += curDelta.y
									
									knots.push({x: curPoint.x, y: curPoint.y})
									
									let idx = FRAME_WIDTH * curPoint.y * 4 + curPoint.x * 4

									imdata.data[idx] = red
									imdata.data[idx + 1] = green
									imdata.data[idx + 2] = blue
									imdata.data[idx + 3] = 255
								}
							}
						}
					}
					
					for (let y = 0, rows = FRAME_HEIGHT; y < rows; y++) {
						for (let x = 0, cols = FRAME_WIDTH - 1; x < cols; x++) {
							let idx = y * FRAME_WIDTH * 4 + x * 4
							let idx_next = y * FRAME_WIDTH * 4 + (x+1) * 4
							if (imdata.data[idx_next + 3] != 255) {
								imdata.data[idx_next] = imdata.data[idx]
								imdata.data[idx_next + 1] = imdata.data[idx + 1]
								imdata.data[idx_next + 2] = imdata.data[idx + 2]
								imdata.data[idx_next + 3] = 255
							}
						}
					}
					
					ctx.putImageData(imdata, 0, 0)
					state.fIndex++
					
					let fTime = Number(new Date) - sTime
					//state.prevFrame = imdata.data
					if (fTime > 41) {
						setTimeout(playFrame, 0)
					} else {
						setTimeout(playFrame, 41 - fTime)
					}
				}
				playFrame()
            }
            reader.readAsArrayBuffer(bitstream)
        }
        xhrData.open('GET', 'chroma.txt', true)
        xhrData.send(null)
    </script>
</body>
</html>