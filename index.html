<!DOCTYPE html>
<html lang="en">
<head>
    <style type="text/css">
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        margin: 0;
        padding: 0;
		background: #000000;
    }
    </style>
    <title>vecvid</title>
</head>
<body>
    <script src="primitives/Primitive.js"></script>
	<script src="primitives/Lineto.js"></script>
	<script src="primitives/Moveto.js"></script>
	<script src="primitives/BezierCurve.js"></script>
    <script src="jSignature.js"></script>
    <script src="simplify.js"></script>
    <script>
		const FRAME_WIDTH = 1920
		const FRAME_HEIGHT = 800
	
        let canvasEl = document.createElement('canvas')
        canvasEl.width = FRAME_WIDTH
        canvasEl.height = FRAME_HEIGHT
		let canvasWidth = innerWidth
		let canvasHeight = 800/1920 * innerWidth
		canvasEl.style.width = canvasWidth + 'px'
		canvasEl.style.height = canvasHeight + 'px'
		canvasEl.style.margin = ((innerHeight - canvasHeight) / 2) + 'px 0px'
        document.body.appendChild(canvasEl)

        let ctx = canvasEl.getContext('2d')

        let xhrData = new XMLHttpRequest
        xhrData.responseType = 'blob'
        xhrData.onload = function () {
            let reader = new FileReader
            let bitstream = this.response
            reader.onload = function () {
                let bytes = this.result
                let byteLen = bytes.length
                let bitIndex = 0
                let byteIndex = 0
				let state = {ready: false}
				
				let pos = 0
				let frameSizes = []
				let frameCount = bytes.charCodeAt(pos) << 8 | bytes.charCodeAt(pos + 1) & 0xFF
				pos = 2
				//frameCount--
				function getBit() {
					if (bitIndex == 8) {
						bitIndex = 0
						byteIndex++
					}
					if (byteIndex >= byteLen) {
						return false
					}
					let bit = (bytes.charCodeAt(byteIndex) & (1 << (7 - bitIndex))) != 0 ? '1' : '0'
					bitIndex++
					return bit
				}
				
				function getByte() {
					return getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit()
				}

				let mSmallDeltas = {
					0b00: -1,
 					0b01: 0,
					0b10: 1
					/*0b000: {x: -1, y: -1},
					0b001: {x: -1, y: 0},
					0b010: {x: -1, y: 1},
					0b011: {x: 0, y: -1},
					0b100: {x: 0, y: 1},
					0b101: {x: 1, y: -1},
					0b110: {x: 1, y: 0},
					0b111: {x: 1, y: 1}*/
				}

				let byteIdx = 2
				for (let i = 0; i < frameCount; i++) {
					let frameBytes = bytes.charCodeAt(pos) << 16 | bytes.charCodeAt(pos+1) << 8 | bytes.charCodeAt(pos+2) & 0xFF
					let frameBits = bytes.charCodeAt(pos+3) & 0xFF
					byteIdx += frameBytes
					frameSizes.push({bytes: byteIdx, bits: frameBits})
					pos += 4
				}
				console.log(frameSizes)
				
				state.fIndex = 0
				
				let preBytes = pos
				
				function playFrame() {
				    let sTime = Number(new Date)
					if (state.fIndex>0) {
						byteIndex = preBytes - 2 + frameSizes[state.fIndex].bytes
						bitIndex = frameSizes[state.fIndex].bits
					}
					else {
						byteIndex = pos
						bitIndex = 0
					}

					let colorCount = getByte() << 8
					colorCount |= getByte()

					let shapes = []
					let colors = []

					ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)

					let imdata = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)

					for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
						if (getBit() == '0') {
							continue;
						}
						let red = getByte()
						let green = getByte()
						let blue = getByte()

						let contourCount = getByte() << 8
						contourCount |= getByte()
						
						let knots = []

						for (let contourIndex = 0; contourIndex < contourCount; contourIndex++) {
							let firstPointX = getByte() << 8
							firstPointX |= getByte()
							
							let firstPointY = getByte() << 8
							firstPointY |= getByte()

							let innerContourCount = getByte() << 8
							innerContourCount |= getByte()

							let curPoint = {x: firstPointX, y: firstPointY}
							let curDelta = {x: 0, y: 0}

							let idx = FRAME_WIDTH * curPoint.y * 4 + curPoint.x * 4
							imdata.data[idx] = red
							imdata.data[idx + 1] = green
							imdata.data[idx + 2] = blue
							imdata.data[idx + 3] = 255

							knots.push(curPoint)

							for (let innerContourIndex = 1; innerContourIndex < innerContourCount; innerContourIndex++) {
								let bitIsDifferent = getBit() == '1'

								if (bitIsDifferent) {
									let x;
									let y;
									if (getBit() == '1') {
										x = (getBit() == '1' ? -1 : 1) * (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
										y = (getBit() == '1' ? -1 : 1) * (getBit() << 11 | getBit() << 10 | getBit() << 9 | getBit() << 8 | getBit() << 7 | getBit() << 6 | getBit() << 5 | getBit() << 4 | getBit() << 3 | getBit() << 2 | getBit() << 1 | getBit())
									} else {
										x = mSmallDeltas[getBit() << 1 | getBit()]
										y = mSmallDeltas[getBit() << 1 | getBit()]
									}
									curDelta = {x: x, y: y}
								} else {
								}
								
								curPoint.x += curDelta.x
								curPoint.y += curDelta.y
								
								knots.push({x: curPoint.x, y: curPoint.y})
								
								let idx = FRAME_WIDTH * curPoint.y * 4 + curPoint.x * 4

								imdata.data[idx] = red
								imdata.data[idx + 1] = green
								imdata.data[idx + 2] = blue
								imdata.data[idx + 3] = 255
							}
							
							shapes.push(knots)
							knots = []
						}
					}
					
					for (let y = 0, rows = FRAME_HEIGHT; y < rows; y++) {
						for (let x = 0, cols = FRAME_WIDTH - 1; x < cols; x++) {
							let idx = y * FRAME_WIDTH * 4 + x * 4
							let idx_next = y * FRAME_WIDTH * 4 + (x+1) * 4
							if (imdata.data[idx_next + 3] != 255) {
								imdata.data[idx_next] = imdata.data[idx]
								imdata.data[idx_next + 1] = imdata.data[idx + 1]
								imdata.data[idx_next + 2] = imdata.data[idx + 2]
								imdata.data[idx_next + 3] = 255
							}
						}
					}
					
					ctx.putImageData(imdata, 0, 0)

					/*ctx.lineWidth = 1
					ctx.lineCap = 'round'
					ctx.lineJoin = 'round'
					ctx.strokeStyle = '#000000'
					for (let shapeIndex = 0, shapeCount = shapes.length; shapeIndex < shapeCount; shapeIndex++) {
						//colors[shapeIndex]
						let knots = shapes[shapeIndex]
						

						let strokey = {x: [], y: []}
						for (let knotIndex = 0, knotCount = knots.length; knotIndex < knotCount; knotIndex++) {
							strokey.x.push(knots[knotIndex].x)
							strokey.y.push(knots[knotIndex].y)
						}
						let prims = addstroke(strokey, 0, 0)
						ctx.lineWidth = 2
						ctx.beginPath()
						ctx.moveTo(knots[0].x, knots[0].y)
						for (let knotIndex = 1, knotCount = knots.length; knotIndex < knotCount; knotIndex++) {
							ctx.lineTo(knots[knotIndex].x, knots[knotIndex].y)
						}
						//for (let primIndex = 0, primCount = prims.length; primIndex < primCount; primIndex++) {
						//	prims[primIndex].render(ctx)
						//}
						//ctx.closePath()
						ctx.stroke()
					}*/
					
					state.fIndex++
					let fTime = Number(new Date) - sTime
					//state.prevFrame = imdata.data
					if (fTime > 41) {
						setTimeout(playFrame, 0)
					} else {
						setTimeout(playFrame, 41 - fTime)
					}
				}
				playFrame()
            }
            reader.readAsBinaryString(bitstream)
        }
        xhrData.open('GET', 'chroma.txt', true)
        xhrData.send(null)
    </script>
</body>
</html>